<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System;

namespace Unknown6656;

<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    for (int dim = 1; dim < maxdim; ++dim)
    {
        var pars_types = string.Join(", ", r(1, dim).Select(i => $"Index{i}"));
        var pars_names = string.Join(", ", r(1, dim).Select(i => $"i{i}"));
        var pars_decls = string.Join(", ", r(1, dim).Select(i => $"Index{i} i{i}"));
        var pars_dtypes = string.Join(", ", r(1, dim).Select(i => $"in Index{i}"));


        generate_indexer_declaration(dim, pars_types, pars_decls, pars_names, true, true);
        generate_indexer_declaration(dim, pars_types, pars_decls, pars_names, true, false);
        generate_indexer_declaration(dim, pars_types, pars_decls, pars_names, false, true);
#>

/// <summary>
/// Represents a ref function of the form "<#=pars_types#> -> <see langword="ref"/> Value".
/// </summary>
/// <inheritdoc cref="Func{<#=pars_types#>, Value}"/>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
/// <typeparam name="Index<#=i#>">Generic <typeparamref name="Index<#=i#>"/> parameter type.</typeparam>
<#
        }
#>
/// <typeparam name="Value">Generic <typeparamref name="Value"/> return type.</typeparam>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
/// <param name="i<#=i#>"><typeparamref name="Index<#=i#>"/> parameter</param>
<#
        }
#>
/// <returns><see langword="ref"/> <typeparamref name="Value"/> return value.</returns>
public delegate ref Value RefFunc<<#=pars_dtypes#>, Value>(<#=pars_decls#>);

/// <summary>
/// Represents a read/write <see langword="ref"/> indexer to be used for indexable properties.
/// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
/// <typeparam name="Index<#=i#>">Generic <typeparamref name="Index<#=i#>"/> indexing type (the key type).</typeparam>
<#
        }
#>
/// <typeparam name="Value">Generic value type.</typeparam>
public sealed partial class RefIndexer<<#=pars_types#>, Value>
{
    private readonly RefFunc<<#=pars_types#>, Value> _func;


    /// <summary>
    /// The indexer's accessor.
    /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <param name="i<#=i#>">Index no. <#=i#></param>
<#
        }
#>
    /// <returns>Value reference</returns>
    public ref Value this[<#=pars_decls#>] => ref _func(<#=pars_names#>);


    /// <summary>
    /// Creates a new ref indexer.
    /// </summary>
    /// <param name="func">Ref getter function</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RefIndexer(RefFunc<<#=pars_types#>, Value> func) => _func = func ?? throw new ArgumentNullException(nameof(func));

    public Indexer<<#=pars_types#>, Value> AsIndexer() => new(AsReadOnly(), AsWriteOnly());

    /// <summary>
    /// Returns the read-only indexer derived from the current instance, which includes only the getter-function.
    /// </summary>
    /// <returns>The read-only indexer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ReadOnlyIndexer<<#=pars_types#>, Value> AsReadOnly() => new((<#=pars_decls#>) => _func(<#=pars_names#>));

    /// <summary>
    /// Returns the write-only indexer derived from the current instance, which includes only the setter-function.
    /// </summary>
    /// <returns>The write-only indexer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public WriteOnlyIndexer<<#=pars_types#>, Value> AsWriteOnly() => new((<#=pars_decls#>, Value v) => _func(<#=pars_names#>) = v);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RefFunc<<#=pars_types#>, Value> AsFunction() => _func;

    /// <summary>
    /// Returns the ref function derived from the given ref indexer.
    /// </summary>
    /// <param name="indexer">Generic ref indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator RefFunc<<#=pars_types#>, Value>(RefIndexer<<#=pars_types#>, Value> indexer) => indexer.AsFunction();

    /// <summary>
    /// Returns the read/write indexer derived from the given ref indexer.
    /// </summary>
    /// <param name="indexer">Generic indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Indexer<<#=pars_types#>, Value>(RefIndexer<<#=pars_types#>, Value> indexer) => indexer.AsIndexer();

    /// <summary>
    /// Returns the read-only indexer derived from the given ref indexer.
    /// </summary>
    /// <param name="indexer">Generic indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator ReadOnlyIndexer<<#=pars_types#>, Value>(RefIndexer<<#=pars_types#>, Value> indexer) => indexer.AsReadOnly();

    /// <summary>
    /// Returns the write-only indexer derived from the given ref indexer.
    /// </summary>
    /// <param name="indexer">Generic indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator WriteOnlyIndexer<<#=pars_types#>, Value>(RefIndexer<<#=pars_types#>, Value> indexer) => indexer.AsWriteOnly();

    /// <summary>
    /// Returns the ref indexer derived from the given ref function.
    /// </summary>
    /// <param name="func">Generic ref function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator RefIndexer<<#=pars_types#>, Value>(RefFunc<<#=pars_types#>, Value> func) => new(func);
}
<#
    }
#>
<#+
const string RW_INDEXER = "Indexer";
const string RO_INDEXER = "ReadOnlyIndexer";
const string WO_INDEXER = "WriteOnlyIndexer";

IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

void generate_indexer_declaration(int dim, string pars_types, string pars_decls, string pars_names, bool @set, bool @get)
{
    string typename = @set && @get ? RW_INDEXER : @get ? RO_INDEXER : WO_INDEXER;
#>

/// <summary>
/// Represents a <#=@set && @get ? "read/write" : @set ? "write-only" : "read-only"#> indexer to be used for indexable properties.
/// </summary>
<#+
        for (int i = 1; i <= dim; ++i)
        {
#>
/// <typeparam name="Index<#=i#>">Generic <typeparamref name="Index<#=i#>"/> indexing type (the key type)</typeparam>
<#+
        }
#>
/// <typeparam name="Value">Generic value type</typeparam>
public sealed class <#=typename#><<#=pars_types#>, Value>
{
<#+
    generate_indexer_body(dim, typename, pars_types, pars_decls, pars_names, @set, @get);

    if (@set && @get)
    {
#>
    /// <summary>
    /// Creates a new indexer.
    /// </summary>
    /// <param name="getter">Getter function</param>
    /// <param name="setter">Setter function</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=typename#>(Func<<#=pars_types#>, Value> getter, Action<<#=pars_types#>, Value> setter)
    {
        SetterFunction = setter ?? throw new ArgumentNullException(nameof(setter));
        GetterFunction = getter ?? throw new ArgumentNullException(nameof(getter));
    }

    /// <summary>
    /// Creates a new indexer.
    /// </summary>
    /// <param name="getter">Getter function</param>
    /// <param name="setter">Setter function</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=typename#>(<#=RO_INDEXER#><<#=pars_types#>, Value> getter, <#=WO_INDEXER#><<#=pars_types#>, Value> setter)
        : this(getter.AsFunction(), setter.AsFunction())
    {
    }
<#+
    }
#>
}
<#+
}

void generate_indexer_body(int dim, string typename, string pars_types, string pars_decls, string pars_names, bool @set, bool @get)
{
#>
    <#=@set?"":"// "#>public Action<<#=pars_types#>, Value> SetterFunction { get; private set; }
    <#=@get?"":"// "#>public Func<<#=pars_types#>, Value> GetterFunction { get; private set; }

<#+
    generate_accessor(dim, typename, @set, @get);

    if (@get ^ @set)
    {
        string ftypename = @get ? "Func" : "Action";
#>
    /// <summary>
    /// Creates a new <#=@get ? "read" : "write" #>-only indexer.
    /// </summary>
    /// <param name="func">The indexer's <#=@get ? "getter" : "setter" #> function</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=typename#>(<#=ftypename#><<#=pars_types#>, Value> func) => <#=@get ? "Getter" : "Setter" #>Function = func ?? throw new ArgumentNullException(nameof(func));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=ftypename#><<#=pars_types#>, Value> AsFunction() => <#=@get ? "Getter" : "Setter" #>Function;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#=ftypename#><<#=pars_types#>, Value>(<#=typename#><<#=pars_types#>, Value> indexer) => indexer.AsFunction();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#=typename#><<#=pars_types#>, Value>(<#=ftypename#><<#=pars_types#>, Value> func) => new(func);
<#+
    }
    else
    {
        generate_writeonly_indexer_body(dim, typename, pars_types, pars_decls, pars_names);
        generate_readonly_indexer_body(dim, typename, pars_types, pars_decls, pars_names);
    }
}

void generate_readonly_indexer_body(int dim, string typename, string pars_types, string pars_decls, string pars_names)
{
#>
    /// <summary>
    /// Returns the read-only indexer derived from the current instance, which includes only the getter function.
    /// </summary>
    /// <returns>The read-only indexer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=RO_INDEXER#><<#=pars_types#>, Value> AsReadOnly() => new(GetterFunction);

    /// <summary>
    /// Returns the read-only indexer derived from the given indexer.
    /// </summary>
    /// <param name="indexer">Generic indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#=RO_INDEXER#><<#=pars_types#>, Value>(<#=typename#><<#=pars_types#>, Value> indexer) => indexer.AsReadOnly();

<#+
}

void generate_writeonly_indexer_body(int dim, string typename, string pars_types, string pars_decls, string pars_names)
{
#>
    /// <summary>
    /// Returns the write-only indexer derived from the current instance, which includes only the setter function.
    /// </summary>
    /// <returns>The read-only indexer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=WO_INDEXER#><<#=pars_types#>, Value> AsWriteOnly() => new(SetterFunction);

    /// <summary>
    /// Returns the write-only indexer derived from the given indexer.
    /// </summary>
    /// <param name="indexer">Generic indexer.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator <#=WO_INDEXER#><<#=pars_types#>, Value>(<#=typename#><<#=pars_types#>, Value> indexer) => indexer.AsWriteOnly();

<#+
}

void generate_accessor(int dim, string typename, bool @set, bool @get)
{
    for (int i = 1; i <= dim; ++i)
    {
        bool curryied = i < dim;
        string pars_decls = string.Join(", ", r(1, i).Select(j => $"Index{j} i{j}"));
        string pars_names = string.Join(", ", r(1, i).Select(j => $"i{j}"));
#>

    /// <summary>
    /// The indexer's <#=curryied ? "curryied " : ""#>accessor.
    /// </summary>
<#+
        for (int j = 1; j <= i; ++j)
        {
#>
    /// <param name="i<#=j#>">Index no. <#=j#></param>
<#+
        }

        if (curryied)
        {
            string curr_pars = string.Join(", ", r(i + 1, dim - i).Select(j => $"i{j}"));
            string curr_type = string.Join(", ", r(i + 1, dim - i).Select(j => $"Index{j}"));
#>
    /// <returns>Partially applied indexer</returns>
    public <#=typename#><<#=curr_type#>, Value> this[<#=pars_decls#>] => Curry(<#=pars_names#>);

    /// <summary>
    /// Returns a partially applied indexer based on the given indices.
    /// </summary>
<#+
            for (int j = 1; j <= i; ++j)
            {
#>
    /// <param name="i<#=j#>">Index no. <#=j#></param>
<#+
            }
#>
    /// <returns>Partially applied indexer</returns>
    public <#=typename#><<#=curr_type#>, Value> Curry(<#=pars_decls#>) => new(
<#+
            if (@get)
                Write($"({curr_pars}) => this[{pars_names}, {curr_pars}]{(@set?",":"")}");

            if (@set)
                Write($"({curr_pars}, value) => this[{pars_names}, {curr_pars}] = value");
#>
    );
<#+
        }
        else
        {
#>
    /// <returns>Value</returns>
    public Value this[<#=pars_decls#>]
    {
<#+
            if (@set)
            {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => SetterFunction(<#=pars_names#>, value);
<#+
            }

            if (@get)
            {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => GetterFunction(<#=pars_names#>);
<#+
            }
#>
    }

<#+
        }
    }
}
#>
